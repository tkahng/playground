// Code generated by BobGen psql v0.31.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"database/sql/driver"
	"fmt"
)

// Enum values for ProviderTypes
const (
	ProviderTypesOauth       ProviderTypes = "oauth"
	ProviderTypesCredentials ProviderTypes = "credentials"
)

func AllProviderTypes() []ProviderTypes {
	return []ProviderTypes{
		ProviderTypesOauth,
		ProviderTypesCredentials,
	}
}

type ProviderTypes string

func (e ProviderTypes) String() string {
	return string(e)
}

func (e ProviderTypes) Valid() bool {
	switch e {
	case ProviderTypesOauth,
		ProviderTypesCredentials:
		return true
	default:
		return false
	}
}

func (e ProviderTypes) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *ProviderTypes) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e ProviderTypes) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *ProviderTypes) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e ProviderTypes) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *ProviderTypes) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = ProviderTypes(x)
	case []byte:
		*e = ProviderTypes(x)
	case nil:
		return fmt.Errorf("cannot nil into ProviderTypes")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid ProviderTypes value: %s", *e)
	}

	return nil
}

// Enum values for Providers
const (
	ProvidersGoogle      Providers = "google"
	ProvidersApple       Providers = "apple"
	ProvidersFacebook    Providers = "facebook"
	ProvidersGithub      Providers = "github"
	ProvidersCredentials Providers = "credentials"
)

func AllProviders() []Providers {
	return []Providers{
		ProvidersGoogle,
		ProvidersApple,
		ProvidersFacebook,
		ProvidersGithub,
		ProvidersCredentials,
	}
}

type Providers string

func (e Providers) String() string {
	return string(e)
}

func (e Providers) Valid() bool {
	switch e {
	case ProvidersGoogle,
		ProvidersApple,
		ProvidersFacebook,
		ProvidersGithub,
		ProvidersCredentials:
		return true
	default:
		return false
	}
}

func (e Providers) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *Providers) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e Providers) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *Providers) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e Providers) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *Providers) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = Providers(x)
	case []byte:
		*e = Providers(x)
	case nil:
		return fmt.Errorf("cannot nil into Providers")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid Providers value: %s", *e)
	}

	return nil
}

// Enum values for StripePricingPlanInterval
const (
	StripePricingPlanIntervalDay   StripePricingPlanInterval = "day"
	StripePricingPlanIntervalWeek  StripePricingPlanInterval = "week"
	StripePricingPlanIntervalMonth StripePricingPlanInterval = "month"
	StripePricingPlanIntervalYear  StripePricingPlanInterval = "year"
)

func AllStripePricingPlanInterval() []StripePricingPlanInterval {
	return []StripePricingPlanInterval{
		StripePricingPlanIntervalDay,
		StripePricingPlanIntervalWeek,
		StripePricingPlanIntervalMonth,
		StripePricingPlanIntervalYear,
	}
}

type StripePricingPlanInterval string

func (e StripePricingPlanInterval) String() string {
	return string(e)
}

func (e StripePricingPlanInterval) Valid() bool {
	switch e {
	case StripePricingPlanIntervalDay,
		StripePricingPlanIntervalWeek,
		StripePricingPlanIntervalMonth,
		StripePricingPlanIntervalYear:
		return true
	default:
		return false
	}
}

func (e StripePricingPlanInterval) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *StripePricingPlanInterval) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e StripePricingPlanInterval) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *StripePricingPlanInterval) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e StripePricingPlanInterval) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *StripePricingPlanInterval) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = StripePricingPlanInterval(x)
	case []byte:
		*e = StripePricingPlanInterval(x)
	case nil:
		return fmt.Errorf("cannot nil into StripePricingPlanInterval")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid StripePricingPlanInterval value: %s", *e)
	}

	return nil
}

// Enum values for StripePricingType
const (
	StripePricingTypeOneTime   StripePricingType = "one_time"
	StripePricingTypeRecurring StripePricingType = "recurring"
)

func AllStripePricingType() []StripePricingType {
	return []StripePricingType{
		StripePricingTypeOneTime,
		StripePricingTypeRecurring,
	}
}

type StripePricingType string

func (e StripePricingType) String() string {
	return string(e)
}

func (e StripePricingType) Valid() bool {
	switch e {
	case StripePricingTypeOneTime,
		StripePricingTypeRecurring:
		return true
	default:
		return false
	}
}

func (e StripePricingType) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *StripePricingType) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e StripePricingType) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *StripePricingType) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e StripePricingType) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *StripePricingType) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = StripePricingType(x)
	case []byte:
		*e = StripePricingType(x)
	case nil:
		return fmt.Errorf("cannot nil into StripePricingType")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid StripePricingType value: %s", *e)
	}

	return nil
}

// Enum values for StripeSubscriptionStatus
const (
	StripeSubscriptionStatusTrialing          StripeSubscriptionStatus = "trialing"
	StripeSubscriptionStatusActive            StripeSubscriptionStatus = "active"
	StripeSubscriptionStatusCanceled          StripeSubscriptionStatus = "canceled"
	StripeSubscriptionStatusIncomplete        StripeSubscriptionStatus = "incomplete"
	StripeSubscriptionStatusIncompleteExpired StripeSubscriptionStatus = "incomplete_expired"
	StripeSubscriptionStatusPastDue           StripeSubscriptionStatus = "past_due"
	StripeSubscriptionStatusUnpaid            StripeSubscriptionStatus = "unpaid"
	StripeSubscriptionStatusPaused            StripeSubscriptionStatus = "paused"
)

func AllStripeSubscriptionStatus() []StripeSubscriptionStatus {
	return []StripeSubscriptionStatus{
		StripeSubscriptionStatusTrialing,
		StripeSubscriptionStatusActive,
		StripeSubscriptionStatusCanceled,
		StripeSubscriptionStatusIncomplete,
		StripeSubscriptionStatusIncompleteExpired,
		StripeSubscriptionStatusPastDue,
		StripeSubscriptionStatusUnpaid,
		StripeSubscriptionStatusPaused,
	}
}

type StripeSubscriptionStatus string

func (e StripeSubscriptionStatus) String() string {
	return string(e)
}

func (e StripeSubscriptionStatus) Valid() bool {
	switch e {
	case StripeSubscriptionStatusTrialing,
		StripeSubscriptionStatusActive,
		StripeSubscriptionStatusCanceled,
		StripeSubscriptionStatusIncomplete,
		StripeSubscriptionStatusIncompleteExpired,
		StripeSubscriptionStatusPastDue,
		StripeSubscriptionStatusUnpaid,
		StripeSubscriptionStatusPaused:
		return true
	default:
		return false
	}
}

func (e StripeSubscriptionStatus) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *StripeSubscriptionStatus) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e StripeSubscriptionStatus) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *StripeSubscriptionStatus) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e StripeSubscriptionStatus) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *StripeSubscriptionStatus) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = StripeSubscriptionStatus(x)
	case []byte:
		*e = StripeSubscriptionStatus(x)
	case nil:
		return fmt.Errorf("cannot nil into StripeSubscriptionStatus")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid StripeSubscriptionStatus value: %s", *e)
	}

	return nil
}

// Enum values for TokenTypes
const (
	TokenTypesReauthenticationToken TokenTypes = "reauthentication_token"
	TokenTypesRefreshToken          TokenTypes = "refresh_token"
	TokenTypesVerificationToken     TokenTypes = "verification_token"
	TokenTypesPasswordResetToken    TokenTypes = "password_reset_token"
	TokenTypesStateToken            TokenTypes = "state_token"
)

func AllTokenTypes() []TokenTypes {
	return []TokenTypes{
		TokenTypesReauthenticationToken,
		TokenTypesRefreshToken,
		TokenTypesVerificationToken,
		TokenTypesPasswordResetToken,
		TokenTypesStateToken,
	}
}

type TokenTypes string

func (e TokenTypes) String() string {
	return string(e)
}

func (e TokenTypes) Valid() bool {
	switch e {
	case TokenTypesReauthenticationToken,
		TokenTypesRefreshToken,
		TokenTypesVerificationToken,
		TokenTypesPasswordResetToken,
		TokenTypesStateToken:
		return true
	default:
		return false
	}
}

func (e TokenTypes) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *TokenTypes) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e TokenTypes) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *TokenTypes) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e TokenTypes) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *TokenTypes) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = TokenTypes(x)
	case []byte:
		*e = TokenTypes(x)
	case nil:
		return fmt.Errorf("cannot nil into TokenTypes")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid TokenTypes value: %s", *e)
	}

	return nil
}

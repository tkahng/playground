types:
  types.JSON[map[string]string]:
    # If true, a test for the random expression will not be generated
    no_randomization_test: true
    imports:
      - '"github.com/stephenafamo/bob/types"'
    # To be used in factory.random_type
    # a variable `f` of type `faker.Faker` is available
    random_expr: |-
      return types.NewJSON(map[string]string{})
    # Imports for the random expression
    # random_expr_imports:
    #   - '"bytes"'
    #   - '"fmt"'
    # CompareExpr is used to compare two values of this type
    # if not provided, == is used
    # Used AAA and BBB as placeholders for the two values
    compare_expr: |-
      reflect.DeepEqual(AAA, BBB)
    compare_expr_imports: ['"reflect"']
psql:
  dsn: "postgres://postgres:postgres@localhost:5432/authgo?sslmode=disable"
  uuid_pkg: "google"
  output: "internal/db/models"
  driver_name: "github.com/jackc/pgx/v5"
tags:
  - "json"
replacements:
  - tables: ["stripe_products", "stripe_prices", "stripe_subscriptions"]
    match:
      name: "metadata"
    replace: "types.JSON[map[string]string]"
# replacements:
#   - tables: [] # What tables to look inside. Matches all tables if empty

#     # The match is a drivers.Column struct, and matches on almost all fields.
#     # Notable exception for the unique bool. Matches are done
#     # with "logical and" meaning it must match all specified matchers.
#     # Boolean values are only checked if all the string specifiers match first,
#     # and they must always match.
#     #
#     # Note there is precedence for types.match, more specific things should appear
#     # further down in the config as once a matching rule is found it is executed
#     # immediately.
#     match:
#       # name: "username" # Matches the column name
#       db_type: "uuid" # Matches the database type
#       # default: "NULL" # Matches the default value
#       # comment: "The username" # Matches the column comment
#       # nullable: true # Matches the nullable value. Defaults to false.
#       # generated: false # Matches the generated value. Defaults to false.
#       # autoincr: false # Matches the autoincr value. Defaults to false.

#     # The replace directive should either reference a pre-configured type, or a type
#     # defined in the `types` configuration.
#     replace: "uuid.String"
# types:
#   uuid:
#     # If true, a test for the random expression will not be generated
#     # no_randomization_test: false
#     imports:
#       - '"github.com/google/uuid"'
#       - '"github.com/stephenafamo/bob/types"'
#     # To be used in factory.random_type
#     # a variable `f` of type `faker.Faker` is available
#     random_expr: |-
#       s := &bytes.Buffer{}
#       s.WriteRune('{')
#       for i := 0; i < f.IntBetween(1, 5); i++ {
#           if i > 0 {
#               fmt.Fprint(s, ", ")
#           }
#           fmt.Fprintf(s, "%q:%q", f.Lorem().Word(), f.Lorem().Word())
#       }
#       s.WriteRune('}')
#       return types.NewJSON[json.RawMessage](s.Bytes())`
